
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // Helper function to check if a user is only removing themselves from a circle
    function isOnlyRemovingSelfFromCircle(request, resource) {
      // User was a member before, but is not after
      let isLeaving = request.auth.uid in resource.data.memberIds &&
                      !(request.auth.uid in request.resource.data.memberIds);

      // The new list of memberIds must be exactly the old list, minus the requester.
      // This prevents them from adding/removing other people.
      let memberIdsCorrectlyUpdated = request.resource.data.memberIds.toSet() == 
                                      resource.data.memberIds.removeAll([request.auth.uid]).toSet();
      
      // The same check for the members map keys.
      let memberMapKeysCorrectlyUpdated = request.resource.data.members.keys().toSet() ==
                                          resource.data.members.keys().removeAll([request.auth.uid]).toSet();
      
      // Allow ownerId to be changed only if the leaver is the current owner
      let ownerChangeAllowed = (resource.data.ownerId == request.resource.data.ownerId) || (resource.data.ownerId == request.auth.uid);
      
      // Check that only allowed fields are being touched
      let allowedFieldsModified = request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds', 'members', 'ownerId']);

      return isLeaving && memberIdsCorrectlyUpdated && memberMapKeysCorrectlyUpdated && ownerChangeAllowed && allowedFieldsModified;
    }
  
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId;
    }
    
    match /transactions/{transactionId} {
      allow read, delete: if request.auth.uid == resource.data.userId;
      allow update: if request.auth.uid == resource.data.userId && request.resource.data.isSplit == false; // Can't edit split transactions
      allow create: if request.auth.uid == request.resource.data.userId;
    }

    match /recurring-expenses/{expenseId} {
      allow read, write: if request.auth.uid == request.resource.data.userId || request.auth.uid == resource.data.userId;
    }
    
    match /friend-requests/{requestId} {
      allow create: if request.auth.uid == request.resource.data.fromUser.uid;
      allow read: if request.auth.uid == resource.data.fromUser.uid || request.auth.uid == resource.data.toUserId;
      allow delete: if request.auth.uid == resource.data.toUserId || request.auth.uid == resource.data.fromUser.uid;
    }
    
    match /friendships/{friendshipId} {
        allow read: if request.auth.uid in resource.data.userIds;
        allow create: if request.auth.uid in request.resource.data.userIds;
        allow delete: if request.auth.uid in resource.data.userIds;
    }
    
    match /circles/{circleId} {
      allow read: if request.auth.uid in resource.data.memberIds;
      allow create: if request.auth.uid == request.resource.data.ownerId;
      allow update: if request.auth.uid == resource.data.ownerId || isOnlyRemovingSelfFromCircle(request, resource);
      allow delete: if false; // Circles are not deleted directly
    }

    match /debts/{debtId} {
      allow create: if request.auth.uid in request.resource.data.involvedUids;
      allow read: if request.auth.uid in resource.data.involvedUids;
      allow update: if request.auth.uid in resource.data.involvedUids;
      allow delete: if request.auth.uid == get(/databases/$(database)/documents/circles/$(resource.data.circleId)).data.ownerId;
    }

    match /notifications/{notificationId} {
      allow read, update, delete: if request.auth.uid == resource.data.userId;
      allow create: if request.auth.uid == request.resource.data.fromUser.uid;
    }
  }
}
